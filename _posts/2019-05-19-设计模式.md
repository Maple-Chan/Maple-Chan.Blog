---
layout: post
title:  "设计模式"
date:   2019-05-19
excerpt: "不断强化自己的开发技能"
tag:
- 设计模式
---



<center><H2><b> 设计模式 </b></H2></center><br>

### 序 

​	不能滥用static。

​	正常的设计模式上不能随便使用static变量，应该先懂得如何编写足以证明“赋值结果冲突、混乱”的测试用例，然后再使用static变量<sup>[[1]](https://bbs.csdn.net/topics/392167990?page=1)</sup>。



### 目录

<b>生产者消费者模式</b>

<b>观察者模式</b>

<b>单例模式</b>

<b>工厂模式</b>

<b>模板模式</b>










### **模板模式**

> [Java设计模式—模板方法模式](https://blog.csdn.net/qq_25827845/article/details/51868973?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase)

```java
package Java_test;
/**
	模板设计模式，定义一个抽象类，其中有抽象方法和具体方法，具体方法调用抽象方法。抽象方法可以有所继承的子类进行自定义，这就是模板设计模式。
	不同的子类根据子类的不同定义，执行不同的算法。（也可以核心算法固定，中间可以定义一些自定义算法，例如增减排序）
*/
public class TemplatePattern {
    
    public static void main(String[] args) {
        ConcreteClass concreteClass = new ConcreteClass();
        concreteClass.doTemplate();
        TemplateAbstract template = new TemplateAbstract(){
            @Override
            protected void doSomething() {
                System.out.println("doSomething");
            }
            @Override
            protected void customFunction() {
                System.out.println("customFunction");
            }
        };
        template.doTemplate();
    }
}
abstract class TemplateAbstract{
    protected abstract void doSomething();
    protected abstract void customFunction();
    protected void doTemplate(){
        doSomething();
        customFunction();
    }
}
class ConcreteClass extends TemplateAbstract{
    @Override
    protected void doSomething() {
        System.out.println("自定义doSomthing");
    }
    @Override
    protected void customFunction() {
        System.out.println("自定义customFunction");
    }
}
```



### **观察者模式**

**定义：**

定义对象间一种**一对多**的依赖关系，使得每当一个对象改变状态，则所有**依赖它的对象**都会得到通知并**自动更新**。该设计模式最重要的作用就是 解耦！将观察者与被观察者解耦，使得他们之间的依赖性更小。

**结构：**

下图的结构是一个为上位机接收下位机状态的设计的一个类图。

> ObserverRole是观察者抽象类。
>
> AlarmLight和DetectIsStop是具体的观察者（订阅者）。
>
> FaultStatusManager是一个具体的被观察者（发布者）。

当被观察者执行addNewStatusChange(msg)之后，被观察者将会调用notifyRoles()，通知所有List当中的对象的时候（通过执行对象中的update方法）。

![1595945154834](https://blog.maplestory.work/images/post_image/2019-05-19-设计模式.assets/1595945154834.png)

```java
package javatest.pattern;

import java.util.ArrayList;
import java.util.List;

/**
 * @description: 本类对观察者设计模式进行实现和测试
 * @modifyContent:
 * @author: Maple Chan
 * @date: 2020-07-28 22:08:06
 * @version: 0.0.1
 */
public class ObservationPattern {
    public static void main(String[] args) {
        FaultStatusPublisher faultStatusPublisher = new FaultStatusPublisher();

        System.out.println("Role1 subscribe an publisher!");
        BaseObserverRole role1 = new AlarmLightRole();
        role1.subscribe(faultStatusPublisher);

        System.out.println("Role2 subscribe an publisher!");
        BaseObserverRole role2 = new DetectIsStopRole();
        role2.subscribe(faultStatusPublisher);
        System.out.println("\n\n\n");


        System.out.println("faultStatusPublisher notify a massage!");
        faultStatusPublisher.addNewStatus("alarm: new Message of :" + AlarmLightRole.class);

        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("\n\n\n");
        System.out.println("faultStatusPublisher notify another massage!");
        faultStatusPublisher.addNewStatus("detect: new Message of :" + DetectIsStopRole.class);

    }
}
/*
发布者、被观察者基类
*/
abstract class BasePublisher {
    protected List<BaseObserverRole> observerRoles = new ArrayList<>();

    /**
     * 注册观察者
     * @param role
     */
    abstract public void attach(BaseObserverRole role);

    /**
     * 调用BaseObserverRoles的update，通知消息。可以考虑从队列中获取消息，实现消息同步接收发送
     * @param msg
     */
    abstract protected void notifyRoles(String msg);

    /**
     * 添加消息，调用notifyRoles方法。可以考虑队列的方式，完成消息的同步
     * @param msg
     */
    abstract public void addNewStatus(String msg);
}
/*
具体的发布者、被观察者
*/
class FaultStatusPublisher extends BasePublisher {
    public void attach(BaseObserverRole role) {
        observerRoles.add(role);
    }

    @Override
    protected void notifyRoles(String msg) {
        observerRoles.forEach((it) -> {
            it.update(msg);
        });
    }

    @Override
    public void addNewStatus(String msg) {
        // TODO Auto-generated method stub
        notifyRoles(msg);
    }
}
/*
观察者基类
*/
abstract class BaseObserverRole {
    protected BasePublisher statusPublisher;

    /**
     * 观察者数据处理方法。
     * 
     * @description 观察者抽象类的必要方法，通过该方法对属于自己的数据进行处理
     * @author Maple Chan
     * @date: 2020-07-28 22:25:46
     * @params
     * @return
     * @param msg
     */
    abstract void update(String msg);

    /**
     * 订阅发布者方法。
     * 
     * @description 观察者抽象类的必要方法,通过该方法进行订阅数据
     * @author Maple Chan
     * @date: 2020-07-28 22:22:53
     * @params statusPublisher
     * @return
     * @param statusPublisher
     */
    abstract void subscribe(BasePublisher statusPublisher);
}

/**
 * @description: 一个观察者的实现类
 * @modifyContent:
 * @author: Maple Chan
 * @date: 2020-07-28 22:32:05
 * @version: 0.0.1
 */
class AlarmLightRole extends BaseObserverRole {
    private final String tag = "alarm";

    @Override
    public void update(String msg) {
        if (msg.contains(tag)) {
            System.out.println("This is AlarmLightRole message, tag is " + tag);
            System.out.println("AlarmLightRole dealing message: " + msg);
        }
    }

    @Override
    void subscribe(BasePublisher faultStatusPublisher) {
        this.statusPublisher = faultStatusPublisher;
        faultStatusPublisher.attach(this);
    }

}

/**
 * @description: 一个观察者的实现类
 * @modifyContent:
 * @author: Maple Chan
 * @date: 2020-07-28 22:32:05
 * @version: 0.0.1
 */
class DetectIsStopRole extends BaseObserverRole {
    private final String tag = "detect";

    @Override
    public void update(String msg) {
        if (msg.contains(tag)) {
            System.out.println("This is DetectIsStopRole message, tag is " + tag);
            System.out.println("DetectIsStopRole dealing message: " + msg);
        }
    }

    @Override
    void subscribe(BasePublisher faultStatusPublisher) {
        this.statusPublisher = faultStatusPublisher;
        faultStatusPublisher.attach(this);
    }

}
```

```java
// 输出：
/*
Role1 subscribe an publisher!
Role2 subscribe an publisher!




faultStatusPublisher notify a massage!
This is AlarmLightRole message, tag is alarm
AlarmLightRole dealing message: alarm: new Message of :class javatest.pattern.AlarmLightRole




faultStatusPublisher notify another massage!
This is DetectIsStopRole message, tag is detect
DetectIsStopRole dealing message: detect: new Message of :class javatest.pattern.DetectIsStopRole
*/

```

通过上述代码，完成了一个由一个发布者发布不同消息，不同的订阅者通过判断传入的消息进行响应的处理。该设计模式充分利用了多态的特性。BaseObserverRole引用不同的实例，在发布者调用notify的时候，将调用BaseObserverRole的update方法，该方法根据不同具体的实例，执行对应的方法。



### 生产者消费者模式

生产者和消费者指的是两个不同的线程类对象，操作同一资源的情况。

- 生产者负责生产数据，消费者负责取走数据
- 生产者每生产一组数据之后，互斥的放入缓冲区，消费者从缓冲区获取数据。
- 上述同步的过程，需要对互斥数据进行同步处理，本下面的代码中通过synchronized进行代码同步。

结构图：

![1596028363129](https://blog.maplestory.work/images/post_image/2019-05-19-设计模式.assets/1596028363129.png)

```java
package javatest.pattern;

import java.util.LinkedList;
import java.util.Random;

/**
 * @description: 生产者消费者设计模式
 * @modifyContent:
 * @author: Maple Chan
 * @date: 2020-07-29 20:31:06
 * @version: 0.0.1
 */
public class ProducerAndConsumer {

    public static void main(String[] args) {
        new Producer().start();
        new ConsumerA().start();
        new ConsumerB().start();
    }
}

class Producer extends Thread {
    private void produce() {
        Goods store = Goods.getInstance();

        // do produce
        long product = new Random().nextLong();
        // put into store
        synchronized (store) {
            System.out.println("生产产品：" + product);
            Goods.goodList.add(product);
        }
    }

    @Override
    public void run() {
        int count = 3;
        while (true) {
            long sleepTime = new Random().nextInt(10) * 100;
            try {
                Thread.sleep(sleepTime);
            } catch (Exception e) {
                // TODO: handle exception
            }
            this.produce();
            if (count-- < 0) {
                break;
            }
        }

        return;
    }
}

class ConsumerA extends Thread {
    private void consumer() {
        Goods store = Goods.getInstance();

        synchronized (store) {
            Long product = Goods.goodList.getFirst();
            Goods.goodList.remove(product);
            System.out.println("消费产品：" + product);
        }
    }
    @Override
    public void run() {
        while (true) {
            long sleepTime = new Random().nextInt(10) * 100;

            try {
                Thread.sleep(sleepTime);
            } catch (Exception e) {
                // TODO: handle exception
            }
            if (Goods.goodList.size() > 0) {
                this.consumer();
            }
        }
    }
}

class ConsumerB extends Thread {
    private void consumer() {
        Goods store = Goods.getInstance();

        synchronized (store) {
            Long product = Goods.goodList.getFirst();
            Goods.goodList.remove(product);
            System.out.println("消费产品：" + product);
        }
    }
    @Override
    public void run() {
        while (true) {
            long sleepTime = new Random().nextInt(10) * 120;

            try {
                Thread.sleep(sleepTime);
            } catch (Exception e) {
                // TODO: handle exception
            }
            // 库存有东西才会进行消费
            if (Goods.goodList.size() > 0) {
                this.consumer();
            }
        }

    }
}

class Goods {

    public static LinkedList<Long> goodList;
    private static Goods singletonGoods;
    private Goods() {
    }
    static {
        goodList = new LinkedList<>();
        singletonGoods = new Goods();
    }
    /**
     * 单例
     */
    public static Goods getInstance() {
        return singletonGoods;
    }
}
```

输出如下所示：

```java
/*
生产产品：6805117464760743258
消费产品：6805117464760743258
生产产品：1599562522443449507
生产产品：1041166688112309013
消费产品：1599562522443449507
生产产品：124370676431480001
消费产品：1041166688112309013
生产产品：7414022159762949506
消费产品：124370676431480001
消费产品：7414022159762949506

代码中生产5个数据，之后消费将一直等待。
*/
```



