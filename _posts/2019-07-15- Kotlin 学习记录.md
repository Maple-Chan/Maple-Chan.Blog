---
layout: post
title:  "Kotlin 学习记录"
date:   2019-07-15
excerpt: "浙大成功软件实习、学习"
tag:
- Kotlin
---



<center><H2><b> Kotlin 学习记录 </b></H2></center><br>

	本文只记录重要的或者与C/C++、Java 出入较大的内容

## Kotlin 变、常量用法

1. 在类中定义变量必须初始化，暂时不能初始化的可用**lateinit**[后期初始化]关键字声明

2. **lateinit**只能声明于 var 变量（不能为可空变量、不能为基本数据类型、使用变量前必须赋值）

3. 延后初始化。只能用于只读变量。

``` kotlin
// 声明一个延迟初始化的字符串数组变量
private val mTitles : Array<String> by lazy {
arrayOf(
        ctx.getString(R.string.tab_title_android),
        ctx.getString(R.string.tab_title_ios),
        ctx.getString(R.string.tab_title_h5)
)
}

// 声明一个延迟初始化的字符串
private val mStr : String by lazy{
"我是延迟初始化字符串变量"
}
```

4. val 不是常量，是不可修改的变量。常量为 const val 且 const 不能用于修饰var

5. 常量声明的三种正确方式

```kotlin
// 1. 顶层声明
const val NUM_A : String = "顶层声明"

// 2. 在object修饰的类中
object TestConst{
    const val NUM_B = "object修饰的类中"
}

// 3. 伴生对象中
class TestClass{
    companion object {
        const val NUM_C = "伴生对象中声明"
    }
}

fun main(args: Array<String>) {
    println("NUM_A => $NUM_A")
    println("NUM_B => ${TestConst.NUM_B}")
    println("NUM_C => ${TestClass.NUM_C}")
}常量声明的三种正确方式
```



## 数据类型

1. Kotlin当中不支持8进制

```kotlin
var num16 = 0x0F
var num2 = 0b11110001
var num10 = 123
```

2. Kotlin中可以通过下划线作数值中的逗号

```kotlin
var oneMillion = 1_000_000
println("var oneMillion = 1_000_000 => var oneMillion = $oneMillion")
```

3. 数值比较：== 比较值，===比较内存中的地址

4. 位运算大有不同：

```kotlin
    var operaNum = 2

    var shlnum = operaNum shl(2)
    var shrnum = operaNum shr(2)
    var ushrnum = operaNum ushr(2)

    println(" shlOperaNum => $shlnum \n" +
            " shrOperaNum => $shrnum \n" +
            " ushrOperaNum => $ushrnum \n " )
```

​	`Kotlin`中对于按位操作，和Java是有很大的差别的。`Kotlin`中没有特殊的字符，但是只能命名为可以以中缀形式调用的函数，下列是按位操作的完整列表(仅适用于整形（`Int`）和长整形（`Long`）)：

> *  `shl(bits)` => 有符号向左移 (类似`Java`的`<<`)
> *  `shr(bits)` => 有符号向右移 (类似`Java`的`>>`)
>
> *  `ushr(bits)` => 无符号向右移 (类似`Java`的`>>>`)
>
> *  `and(bits)` => 位运算符 `and` (同`Java`中的按位与)
>
> *  `or(bits)` => 位运算符 `or` (同`Java`中的按位或)
>
> *  `xor(bits)` => 位运算符 `xor` (同`Java`中的按位异或)
>
> * `inv()` => 位运算符 按位取反 (同`Java`中的按位取反)

5. 数组分 `arrayOf()`, `arrayOfNulls()`, `Array()`, `原始类型数组`



## 逻辑控制

1. `IF`

​       需要注意，Kotlin中没有三元运算符 `:?`, 因为`if`表达式会有返回值，当条件内逻辑为代码段时，则选择最后一句的值作为返回值。

2. `FOR`

​       Kotlin中不再有 `for(int i=0;i<n;++i)` 这种语法。

> - 关键字 until
>
> ```kotlin
> for (i in 0 until 5){
> print("i => $i \t") //until[0,5)
> }
> ```
>
> - 关键词downTo
>
> ```kotlin
> 	for(i in 15 downTo 0){
> 	print("i=> $i \t") //downTo[15->0]
> 	}
> ```
>
> - 关键符号“..”
>
> ```kotlin
> print("使用 符号`..`的打印结果\n")
> for (i in 20 .. 25){
>   print("i => $i \t")
> }
> println() //输出结果为 	i=>20 i=>21 i=>22 i=>23 i=>24 i=>25	
> ```
>
> - 设置步长
>
> ```kotlin
> for(i in 10 until 16 step 2){
>   print("i => $i \t")  //输出10，12，14
> }
> ```
>
> 
>
> - 迭代
>
> > 提供一个迭代器来遍历任何东西；数组被编译为一个基于索引的循环，**他不会创建一个迭代器对象**
>
> * 遍历字符串
>
>   ```kotlin
>   for (i in "abcdefg"){
>   	print("i => $i \t")
>    }
>   ```
> * 遍历数组
>
> ```kotlin
>    var arrayListOne = arrayOf(10,20,30,40,50)
>    for (i in arrayListOne){
>        print("i => $i \t")
>    }
> ```
>
> * 使用indices遍历数组
>
> ```kotlin
> var arrayListTwo = arrayOf(1,3,5,7,9)
>  for (i in arrayListTwo.indices){
> 	println("arrayListTwo[$i] => " + arrayListTwo[i])
>  }
> ```
>
> 
>
> * 使用withIndex()遍历数组
>
> ```
>    var arrayListTwo = arrayOf(1,3,5,7,9)
>    for ((index,value) in arrayListTwo.withIndex()){
>        println("index => $index \t value => $value")
>    }
> ```
>
> *  使用列表或数组的扩展函数遍历
>
> ```kotlin
>   var arrayListThree = arrayOf(2,'a',3,false,9)
>   var iterator: Iterator<Any> = arrayListThree.iterator()
>    while (iterator.hasNext()){
>        println(iterator.next())
>    }  
> ```
>
> //需要学习 Kotlin中的 it关键字 / Array函数本质 / lamda表达 / 函数定义
>



## Lambda 表达式

1. 语法

  无参数的情况

  ```kotlin
  val fun1 = {9} //定义了一个返回了Int的函数
  
  //该定义参照了情况3
  //传入一个Lambda来表示的形式参数，该形参为一个无参返回Int的函数
  var fun11 : (()->(Int)) ->Int = {initfunc -> initfunc()} 
  
  var value00 = fun11(fun1)
  println("value00 => $value00")
  ```
  有参数的情况

  ```kotlin
  var value1 = 9
  val fun2:(Int,Int)->Double = {a,b-> (a-b).toDouble()}
  var value2 = fun2(value1,3)
  println("value2 => $value2")//输出：value2 => 6.0
  
  //等价形式如下
  var fun3 = {a:Int,b:Int -> a+b}
  var value3 = fun3(3,6)
  
  println("value3 => $value3")//输出：value3 => 9
  //3. lambda表达式作为函数中的参数的时候，这里举一个例子：
  //  fun test(a : Int, 参数名 : (参数1 ： 类型，参数2 : 类型, ... ) -> 表达式返	 //回类型){
  //     ...
  //  }
  //
  
  //下面两个新形式都可以作为value计算的表达式，fun与var功能似乎一样了？NO
  //三种形式定义该test函数，fun声明，var声明，匿名函数。
  //fun test(a:Int,b:Int,add:(Int,Int)->Int):Int{ return add(a,b)}//是一个函数
  //var test: (Int,Int,(Int,Int)->Int) -> Int = {a,b,add -> add(a,b)}//该变量是lambda变量
  
  var test = fun(a:Int,b:Int,add:(Int,Int)->Int):Int{ return add(a,b)} //是一个函数
  
  println("value4 = $value4")
  ```
  ​		`lambda`表达式总是被大括号括着

  ​		定义完整的`Lambda`表达式如上面实例中的语法2，它有其完整的参数类型标注，与表达式返回值。当我们把一些类型标注省略的情况下，就如上面实例中的语法2的另外一种类型。当它推断出的返回值类型不为`Unit`时，它的返回值即为->符号后代码段中的最后一个表达式的类型（如同if-else语句块中的返回值一样）

  ​		当函数的参数仅有一个Lambda表达式的时候可以**省略参数的那个小括号**

2. it

  - it不是关键字
  - it在高阶函数中的lambda表达式的参数只有一个的时候可以使用`it`来使用此参数。`it`可表示**单个参数的隐式名称**

  例子：

  ```kotlin
   fun test(num1 : Int, bool : (Int) -> Boolean) : Int{
     return if (bool(num1)){ num1 } else 0
  }
  
  println(test(10,{it > 5})) // {} 代表这是一个Lambda表达式，无{}会使得编译器不认识it
  println(test(4,{it > 5}))
  ```

  

3. _

  在使用`Lambda`表达式的时候，可以用下划线表示未使用的参数，表示不处理这个参数。

  ```kotlin
  val map = mapOf<String,String>("key1" to "value1","key2" to  "value2","key3" to  "value3")
  
  map.forEach{
      key,value -> println("$key '-' $value")
  }
  map.forEach{
          _,value -> println(" '-' $value")
  }
  ```

  

4. 匿名函数

  ```kotlin
  val test1 = fun (x:Int,y:Int) = x+y; //单表达式函数可以 = 替换 {}
  val test2 = fun (x:Int,y:Int) : Int= x+y;
  val test3 = fun (x:Int,y:Int) : Int{
      return x+y
  }
  println(test1(1,3))
  println(test2(2,3))
  println(test3(3,3))
  
  /**
  //这是错的，fun的需要返回值为Unit，但你给了个Int
      val test4= fun(x:Int,y:Int) {
          return x+y
      } 
  */
  ```

  

5. 带接收者的函数字面值

  6. 匿名函数作为接收者类型

     匿名函数语法允许直接指定函数字面值的接收者类型，如果你需要使用带接收者的函数类型声明一个变量。

```kotlin
val iop = fun  Int.(other:Int):Int = this + other
println(20.iop(2)) //上面的this指的是左边的20 或者是 上面fun后的第一个Int

```


​    

  2. Lambda表达式作为接收者类型

     要用Lambda表达式作为接收者类型的前提是**接收着类型可以从上下文中推断出来

```kotlin


class HTML{
	fun body(){
		println("This is HTML body")
	}
}

fun  html(init: HTML.() -> Unit): HTML{
	val html = HTML()
	html.init()
	return html
}

html {
	body()
}
```


​    

6. 闭包

   闭包，可以函数中包含函数。

   - 携带状态

```kotlin
让函数返回一个函数，并携带状态值

fun test5(a:Int):()->Int{
    println("")
    var b = 3
    return fun():Int{
        println("b=> $b")
        b++
        return b + a
    }
}

var t = test5(3)
println(t()) // 每次执行t函数的时候，b变量的值都是保留了上次执行结束的值，
			 // 因此，叫做携带状态值
println(t())
println(t())
```

* 引用外部变量，并改变外部变量的值

```kotlin
var sum = 0
val arr = arrayOf(1,2,3,4,5,6,7,8,9,10,11)
arr.filter { it<7 }.forEach{sum += it}
//arr.filter { it<7 }.forEach ({sum += it})

println(sum)
```





##  可空类型、空安全、非空断言

1. 判空的方法，if-else / ?. 判断

   ```kotlin
   var str : String? = "12346"
   str = null
   
   println(str?.length) //输出null
   ```

2. 当一个函数/方法有返回值时，如果方法中的代码使用`?.`去返回一个值，那么方法的返回值的类型后面也要加上`?`符号

3. let操作符

   let操作符作用：当使用?.符号时验证时忽略掉null

   ```
   val arrTest : Array<Int?> = arrayOf(1,2,null,3,null,5,6,null)
   
   // 传统写法
   for (index in arrTest) {
       if (index == null){
           continue
       }
       println("index => $index")
   }
   
   // let写法
   for (index in arrTest) {
       index?.let { println("index => $it") }
   }
   
   /**
       index => 1
       index => 2
       index => 3
       index => 5
       index => 6
   */
   ```

   

4. Evils操作符

   安全性操作符有三种：`?:` /` !!` / `as?`

   `?:`

   ```kotlin
   val testStr : String? = null
   
   var length = 0
   
   // 例： 当testStr不为空时，输出其长度，反之输出-1
   
   // 传统写法
   length = if (testStr != null) testStr.length else -1
   
   // ?: 写法
   length = testStr?.length ?: -1
   
   println(length)
   ```

   `!!`

   ```
   val testStr : String? = null
   println(testStr!!.length)
   //如果变量为空，使用!!修饰，运行时会抛出空指针异常
   ```

   `as`

   使用`as`进行强制转换，在不能转换时会抛出异常，而使用`as?`则会返回`null`，但不会抛出异常。



## Kotlin 函数

1. 默认参数

   ```kotlin
   fun defArgs(numA : Int  = 1, numB : Float = 2f, numC : Boolean = false){
       println("numA  =  $numA \t numB = $numB \t numC = $numC")
   }
   
   fun main(args: Array<String>) {
       
       // 默认参数的函数使用
       defArgs()
       defArgs(1,10f,true)
   }
   ```

   

2. 命名参数

   ```kotlin
   callFun("str",isTrue = true,numA = 3) //java中不支持这么写
   ```

   

3. 可变参数

   ​	当一个函数中的参数是不定数量的个数并且是同一个类型，则可是使用`vararg`修饰符去修饰这个变量，则被`vararg`修饰的参数相当于一个固定类型的数组。

   ```kotlin
   fun varargFun(numA: Int, vararg str : String){
           // 遍历
       for (s in str) {
           
       }
   
   // 获取元素
   //    str[index]
   //    str.component1() ... str.component5()
   
   // 或者其高阶函数用法
   //    str.map {  }
   //    str.filter {  }
   //    str.sortBy {  }
   
   }
   
   /*
   普通传递 : varargFun(1,"aaa","bbb","ccc","ddd","fff")
   数组传递：
           val strArray = arrayOf("aaa","bbb","ccc","ddd","fff")
           varargFun(1,*strArray) // *叫做伸展操作符
    */
   ```

   

4. 单表达式函数

   ​	函数具备返回值的时候，可以省略花括号并且在`=`赋值符号之后指定代码体，而函数的返回值是有编辑器自动推断的

   ```kotlin
   // 无参数的情况
   fun test1() = 2                     // 自动推断为：返回类型为Int
   
   // 有参数的情况
   fun test2(num : Int) = num * 2      // 自动推断为：返回类型为Int
   
   // 或者
   fun test3(x : Float, y : Int = 2) = x * y  // 和默认参数一起使用，返回值为Float型
   ```

   

## Class

1. 当类没有结构体时可以省略大括号：`class Test`

2. 主构造函数

   ```kotlin
   class Test constructor(num :Int){
   	//...
   }
   
   class Test (num:Int){
       //...
   }
   ```

   

3. 初始化代码块

   ```kotlin
   class Test constructor(var num:Int){
       init{
        	num = 5
           println("num = $num")
       }
   }
   ```

   

4. 如上，声明属性可以直接在类头声明

5. 当构造函数不具有注释符或者使用默认的可见性修饰符时，可以省略constructor关键字

6. 辅助构造函数

   ```
   class Test{
       constructor(参数){
       }
   }
   ```

   

7. 同时存在主构造函数和二级构造函数

   ​	如果类具有主构造函数，则每个辅助构造函数需要通过另一个辅助构造函数直接或间接地委派给主构造函数。 使用`this`关键字对同一类的另一个构造函数进行委派：

   ```kotlin
   class Class_example2 constructor( num1:Int = 2){
       private var num2 :Int = 30
   
       init {
           println(num1)
           num2
       }
   
       constructor( num1:Int = 2, num3:Int):this(num1){
           println("num3+num1 = $num1 + $num3")
       }
       
       //虽然这里写的是num3，但其实调用的是主构造函数
       constructor(num1: Int = 2,num3: Int,num2:Int):this(num3){ 
           println("constructor - 3 para")
       }
   
   }
   fun main(){
       var c :Class_example2 = Class_example2( 3,num3 = 3)
       var cc:Class_example2 = Class_example2(1,2,3)
   
   }
   
   /*
   输出：
   3
   num3+num1 = 3 + 3
   2      
   constructor - 3 para
   
   */
   ```

   

8. 当类的主构造函数都存在默认值的情况下

   - 在`JVM`上，如果类主构造函数的所有参数都具有默认值，编译器将生成一个额外的无参数构造函数，它将使用默认值。 这使得更容易使用`Kotlin`与诸如`Jackson`或`JPA`的库，通过无参数构造函数创建类实例。
   - 同理可看出，当类存在主构造函数并且有默认值时，二级构造函数也适用
   - 如果第一个第一个参数不是默认的，则不会有无参的，可以调用一个参数的。
   - 总结：如果中间有不具备默认参数的，则到该参数为止都需要进行强制给值，直到参数赋值完或者后面的都是由默认值的形参。

9. 类的实例化

   没有 `new` 关键字。

10. 类的类别

    密封类、内部类、抽象类、枚举类、接口类、数据类





## 属性与字段

1. Getter & Setter
   	1. 在Kotlin中，想要外部变量不能访问某类内的变量则将Setter进行private修饰，若使用private修饰属性则该变量不能对该属性进行访问
    	2. val属性不能有setter函数
    	3. getter一般写，默认实现。写了 get()="修改也不变",则当前属性值永远为“修改也不变”
2. 修改访问器（Getter/Setter）的可见性
   1. get函数前面的可见性修饰符需要和属性一直
   2. 可以用@Inject set 来对实现`Setter`
   3. 共有属性var，setter用private进行修饰，则表示该属性不能外部修改值。

3. 后备字段 [(What is backing field)](https://stackoverflow.com/questions/43220140/whats-kotlin-backing-field-for)

   1. 定义：如果属性使用至少一个访问器的**默认实现**，或者**自定义访问通过field标识符引用**，则将为属性生成后备字段。 （换句话，如果没有默认访问器实现 && 没有自定义通过访问field标识符进行引用，则不会有后备字段）

   2. 原理：Kotlin中没有字段，但有后备字段。在isEmpty例子中可以学习到，判断类中是否为空不需要单独的字段，只需要对size进行判断即可，因此该变量不需要字段。而size则需要后备字段。

      ```kotlin
      class DummyClass {
          var size = 0;
          var isEmpty //no backing field
              get() = size == 0
              set(value) {
                  size = size * 2
              }
      }
      ```

       ```java
         public final class DummyClass {
         private int size;
      
         public final int getSize() {
            return this.size;
         }
      
         public final void setSize(int var1) {
            this.size = var1;
         }
      
         public final boolean isEmpty() {
            return this.size == 0;
         }
      
         public final void setEmpty(boolean value) {
            this.size *= 2;
         }
      }
      
       ```

4. 后备属性

   _table是private 没有法访问，定义了table属性来对 _table进行get操作。

   ```kotlin
   private var _table: Map<String, Int>? = null
   public val table: Map<String, Int>  /// table就是后备属性。
       get() {
           if (_table == null) {
               _table = HashMap() // 初始化
           }
           // ?: 操作符，如果_table不为空则返回，反之则抛出AssertionError异常
           return _table ?: throw AssertionError("Set to null by another thread")
       }
   ```

   

5. 编译时常数

   编译时常数必须为顶层声明，初始化为`String`或者基本类型，没有自定义的getter()

   ```kotlin
   const val CONST_NUM = 5
   const val CONST_STR = "Kotlin"
   ```

6. 后期初始化属性

   只能用于修饰var，没有自定义的setter与getter函数，属性必须为空且类型不能为基本类型。

7. 委托属性



## 修饰符

public、internal、protected、private

1. 顶层声明

   1. 在顶层声明中，文件不能用protected修饰
   2. 不同文件中，访问顶层声明的可以访问，public和internal

2. 在类中声明

   1. 类中可以使用任意修饰符，且类内可以任意访问
   2. 类外的函数，只能访问public和internal

3. 在接口中声明

   1. 只能声明public属性。
   2. 修饰private类和private的方法
   3. 用private修饰的方法不能被实现该接口的类重载。

4. 在构造函数中的声明

   1. 任意使用修饰符
   2. 在二级构造函数中，不能用任意修饰符，可以说是默认修饰（public）

5. 在局部声明中同上步中的二级构造函数

6. 与Java中的对比

   四个修饰符不同、默认修饰符不同



## 继承

1. 超类（Any）；用：符号继承

2. open修饰符

   1. open修饰符是定义继承类的修饰符
   2. 类和成员都需要使用open关键字

3. 继承类的构造函数

   1. 实现类无主构造函数

      每个辅助构造函数必须使用`super`关键字初始化或者委托给另一个构造函数。

   2. 存在主构造函数

      主构造函数一般实现基类中参数最多的构造函数，参数少的哦那个this引用即可。

4. 函数的重写

   1. 子类不能重写基类中没有用open修饰的同名函数。

   2. 当一个类不是用open修饰时，该类默认实final，不能被再次继承

   3. 子类用final关键字修饰方法，以此来禁止后续子类重写该方法。

      ```kotlin
      open class A{
          open fun foo(){}
      }
      
      // B这个类继承类A，并且类B同样使用open修饰符修饰了的
      open class B : Demo(){
         
          // 这里使用final修饰符修饰该方法，禁止覆盖掉类A的foo()函数
          final override fun foo(){}
      }
      ```

      

5.  重写属性

   1. 重写属性必须用override修饰。

   2. 当基类属性修饰为val时，实现类可以用var去重写，反之却不行。

      ```kotlin
      open class Demo{
          open val valStr = "我是用val修饰的属性"
      }
      
      class DemoTest : Demo(){
      
          /*
           * 这里用val、或者var重写都是可以的。
           * 不过当用val修饰的时候不能有setter()函数，编辑器直接会报红的
           */
          
          // override val valStr: String
          //   get() = super.valStr
      
          // override var valStr: String = ""
          //   get() = super.valStr
      
          // override val valStr: String = ""
      
          override var valStr: String = "abc"
              set(value){field = value}
      }
      
      fun main(arge: Array<String>>){
          println(DemoTest().valStr)
      
          val demo = DemoTest()
          demo.valStr = "1212121212"
          println(demo.valStr)
      }
      
      ```

   3. 重写属性是不能用 get() = super.xxx，因为这样的话，不管你是否重新为该属性赋了新值，还是支持`setter()`,在使用的时候都调用的是基类中的属性值。

      ```kotlin
      class DemoTest : Demo(){
      
          /*
           * 这里介绍重写属性是，getter()函数中使用`super`关键字的情况
           */
          
          override var valStr: String = "abc"、
              get() = super.valStr
              set(value){field = value}
      }
      
      fun main(arge: Array<String>>){
          println(DemoTest().valStr)
      
          val demo = DemoTest()
          demo.valStr = "1212121212"
          println(demo.valStr)
      }
      ```

      也不能 get() = this.valStr / get() = valStr 。会报运行错误。

      Exception：StackOverflowError

      java.lang.StackOverflowError:stacksize8MBStackOverflowError是由于当前线程的栈满了,也就是函数调用层级过多导致。堆栈溢出错误一般是递归调用。出现这种异常,大多是由于循环调用。出现的情况:大多数都是在本方法中调用本方法。也就是我们常说的递归调用,所以才导致这个错误的出现。

      应该用默认的 get() = field

6. 在主构造函数重写

   ```kotlin
   class DemoTest2(override var num: Int, override val valStr: String) : Demo()
   
   fun main(args: Array<String>){
       val demo2 = DemoTest2(1,"构造函数中重写")
       println("num = ${demo2.num} \t valStr = ${demo2.valStr}")
   }
   ```

7. 覆盖规则:解决两个接口方法名相同问题

   ```
   open class A{
       open fun test1(){ println("基类A中的函数test1()") }
   
       open fun test2(){println("基类A中的函数test2()")}
   }
   
   interface B{
       fun test1(){ println("接口类B中的函数test1()") }
   
       fun test2(){println("接口类B中的函数test2()")}
   }
   
   class C : A(),B{
       override fun test1() {
           super<A>.test1()
           super<B>.test1()
       }
   
       override fun test2() {
           super<A>.test2()
           super<B>.test2()
       }
   }
   ```

   

   

## 接口类/枚举类

#### 枚举

1. 枚举类的初始化及使用

   ```
   enum class Color(var argb : String){
       RED(""),
       WHITE(""),
       BLACK(""),
       GREEN("")
   }
   ```

   枚举常量，枚举类中的每个枚举常量都是对象，用逗号分隔。（如上述的RED(""),）

   直接用`Color.RED`进行访问。

2. 枚举常量匿名类，必须提供一个抽象方法，且该方法定义在枚举类内部。而且必须在枚举变量的后面，有抽象函数，则最后一个枚举变量必须用`;`隔开。

3. 枚举常量的属性：name（常量名）和ordinal（常量位置）

4. 可以用`enumValues<T>()` 和`enumValuesOf<T>()`访问

   ```
   println(enumValues<Color>().joinToString { it.name })
   println(enumValueOf<Color>("RED"))
   
   //输出
   //RED, WHITE, BLACK, GREEN
   //RED
   ```

   

5. 用 `valueof()`和`values()`检测

   ```
   println(Color.valueOf("RED"))
   println(Color.values()[0])
   println(Color.values()[1])
   println(Color.values()[2])
   println(Color.values()[3])
   ```

   其中，若使用`Color.valueOf("不存在的枚举常量")`，则会抛出`IllegalArgumentException` 异常，即枚举变量不存在。若使用`Color.values()[大于枚举常量位置]`，则会抛出下标越界异常。

   

#### 接口类

1. 用`：`进行对接口的实现
2. Kotlin中接口中可以写属性，作为抽象属性、作为访问器
3. 多接口可用`super<接口名>.方法名`来区分。



## 数据类和密封类

#### 数据类

1. 关键字`data`
2. 构造函数必须存在至少一个参数。
3. 数据类的特性：
   1. 数据类不能是抽象的、开放的、密封的或者内部的。
   2. 数据类可以实现接口，同时也可以继承其他类，如密封类。



#### 密封类

1. 关键字`sealed`
2. sealed class SealedExpr()
3. 密封类**不能被实例化**，他的作用是*表示受限的类继承结构*
4. 密封类可以有多个实例。
5. 密封类的子类必须是在密封类的内部或必须存在于密封类的同一文件，密封类可以有效地保护代码。



## 抽象类&内部类

#### 抽象类

1. 抽象类有抽象成员，抽象成员都带`abstract`关键字
2. Kotlin中的抽象类，在顶层定义时只能使用`public`
3. 抽象类中可以定义内部抽象类
4. 只能继承一个抽象类
5. 抽象类，可以通过子类向上转型
6. 抽象类可以继承另一个类，但不建议用open修饰抽象类

#### 嵌套类类

1. 定义：一个类嵌套在另一个类当中

2. `外部类.嵌套类().嵌套类方法/属性。在调用的时候嵌套类是需要实例化的`。

   ```kotlin
   class Outter{
       class Nested{
           fun execute(){
               Log.d("test", "Nested -> execute")
           }
       }
   }
   
   // 调用
   Outter.Nested().execute()
   
   //输出
   Nested -> execute
   ```

   

#### 内部类

1. 定义：用inner class 来进行声明类

2. 内部类不能直接被实例化，需要外部的类实例化了对象，再利用该对象进行实例化内部类。

   ```kotlin
   class Outter{
       val testVal = "test"
       inner class Inner{
           fun execute(){
               Log.d("test", "Inner -> execute : can read testVal=$testVal")
           }
       }
   }
   
   // 调用
   val outter = Outter()
   outter.Inner().execute()
   
   // 输出
   Inner -> execute : can read testVal=test
   ```

   

3. 监听器的实现方法

   ```kotlin
   package edu.zju.maple.learning
   
   class NickInnerClass{
       lateinit private var listener:OnClickListener
   
       fun setOnClickListener(listener: OnClickListener){
           this.listener = listener
       }
   
       fun activeListener(){
   
           listener.onItemClick()
       }
   
   }
   
   interface OnClickListener{
       fun onItemClick()
   }
   
   fun main(){
       val nick = NickInnerClass()
       nick.setOnClickListener(object:OnClickListener{
           override fun onItemClick() {
   
               println("执行了activeListener函数，才有这句输出")
           }
   
       })
       var i=0;
       while (i<20){
           i++
   
           nick.activeListener() ///唤醒方法
           for ( temp in 1..0xFFFF){
   
           }
   
       }
   }
   ```

   



#### 局部类

1. 局部类只能在定义该局部类的方法中使用
2. 定义在实例方法中的局部类可以访问外部类的所有变量和方法，但不能修改
3. 局部类可以定义属性、方法。



## 高阶函数

1. 将函数作为参数或者返回值的函数称为高阶函数。

   1. ```kotlin
      ///函数作为参数
      private fun resultByOpt(num1 : Int , num2 : Int , result : (Int ,Int) -> Int) : Int{
          return result(num1,num2)
      }
      
      private fun testDemo() {
          val result1 = resultByOpt(1,2){
              num1, num2 ->  num1 + num2
          }
      
          val result2 = resultByOpt(3,4){
              num1, num2 ->  num1 - num2
          }
      
          val result3 = resultByOpt(5,6){
              num1, num2 ->  num1 * num2
          }
      
          val result4 = resultByOpt(6,3){
              num1, num2 ->  num1 / num2
          }
      
          println("result1 = $result1")
          println("result2 = $result2")
          println("result3 = $result3")
          println("result4 = $result4")
      }
      ```

   2. ```kotlin
      ///返回值为函数
      fun test5(a:Int):()->Int{
          println("")
          var b = 3
          return fun():Int{
              println("b=> $b")
              b++
              return b + a
          }
      }
      ```

   

   

2. 常用的标准高阶函数

   1. TODO函数：将会抛出异常，根据参数的内容输出异常内容

   2. run函数：两种用法

      ​	当我们需要执行一个`代码块`的时候就可以用到这个函数,并且这个代码块是独立的。即我可以在`run()`函数中写一些和项目无关的代码，因为它不会影响项目的正常运行。

      ```kotlin
      private fun testRun1() {
          val str = "kotlin"
      
          run{
              val str = "java"   // 和上面的变量不会冲突
              println("str = $str")
          }
      
          println("str = $str")
      }    
      ```

      

      ​	因为`run`函数执行了我传进去的`lambda`表达式并返回了执行的结果，所以当一个业务逻辑都需要执行同一段代码而根据不同的条件去判断得到不同结果的时候。可以用到`run`函数

      ```kotlin
      val index = 3
      val num = run {
          when(index){
              0 -> "kotlin"
              1 -> "java"
              2 -> "php"
              3 -> "javaScript"
              else -> "none"
          }
      }.length
      println("num = $num")
      ```

       

      ​	被一个对象所调用。**当我们传入的lambda表达式想要使用当前对象的上下文的时候，我们可以使用这个函数。**

      ```
      val str = "kotlin"
      str.run {
          println( "length = ${this.length}" )
          println( "first = ${first()}")
          println( "last = ${last()}" )
      }
      ```

      

   3. 同时还有`with` / `let` / `apply` / `also` / `takeIf()` / `takeUnless` / `repeat()` / `lazy()` 分别有不同的用法