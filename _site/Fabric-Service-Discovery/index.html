<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"> <title>Fabric:Service Discovery &#8211; Maple Story</title> <meta name="description" content="Stick to note down what I’v learnt"> <meta name="keywords" content="Hyperledger Fabric"> <!-- Twitter Cards --> <meta name="twitter:card" content="summary"> <meta name="twitter:image" content="halve.png"> <meta name="twitter:title" content="Fabric:Service Discovery"> <meta name="twitter:description" content="Stick to note down what I’v learnt"> <!-- Open Graph --> <meta property="og:locale" content="en_US"> <meta property="og:type" content="article"> <meta property="og:title" content="Fabric:Service Discovery"> <meta property="og:description" content="Stick to note down what I’v learnt"> <meta property="og:url" content="http://localhost:4000/Fabric-Service-Discovery/"> <meta property="og:site_name" content="Maple Story"> <meta property="og:image" content="http://localhost:4000/images/halve.png"> <link rel="canonical" href="http://localhost:4000/Fabric-Service-Discovery/"> <!-- Handheld --> <meta name="HandheldFriendly" content="True"> <meta name="MobileOptimized" content="320"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- Feed --> <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="" /> <!-- Favicons --> <link rel="shortcut icon" type="image/png" href="http://localhost:4000/favicon.png" /> <link rel="shortcut icon" href="http://localhost:4000/favicon.ico" /> <!-- CSS --> <link rel="stylesheet" type="text/css" href="http://localhost:4000/assets/css/main.css"> <!-- Left Block Image for Posts --> <style type="text/css"> #posts.inner-post-page .block-left {background: linear-gradient(rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5)), url(http://localhost:4000/images/unsplash-gallery-image-3.jpg) no-repeat;background-size: cover;} </style> <!-- Left Block Images for Home and Pages --> <style type="text/css"> #posts .block-left {background: linear-gradient(rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5)), url(http://localhost:4000/images/unsplash-image-10.jpg) no-repeat;background-size: cover, cover;} .block-left {background: linear-gradient(rgba(44,45,51,0.9), rgba(44,45,51,0.9)), url(http://localhost:4000/images/home.jpg) no-repeat;background-size: cover;} </style> </head> <body id="posts" class="inner-post-page"> <div class="block-left"> <div class="content"> <a href="http://localhost:4000" class="logo"><img src="http://localhost:4000/images/halve.png"></a> <div class="post-title-section"> <div class="section-line">Posts <em>/</em></div> <h1 class="section-title">Fabric:Service Discovery </h1> <ul class="tags"> <li><a href="http://localhost:4000/tags#Hyperledger Fabric">Hyperledger Fabric</a></li> </ul> <div class="section-line reverse"><a href="http://localhost:4000/posts">Back to posts</a> <em>/</em></div> </div> </div> </div> <div class="block-right"> <a href="../posts.html" title="posts" class="posts-menu-icon"></a> <a title="projects" class="projects-menu-icon"> <span></span> </a> <div class="inner-post content"> <div class="date-highlight">23 May 2020</div> <center><h2><b>Service Discovery</b></h2></center> <p><br /></p> <blockquote> <p>官网链接：<a href="https://hyperledger-fabric.readthedocs.io/en/release-2.0/discovery-overview.html">Service Discovery</a></p> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />为了被服务发现所识别，Peer 节点必须定义一个<a href="#EXTERNAL_ENDPOINT">EXTERNAL_ENDPOINT</a></li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" /><a href="#group_jump">组的概念</a></li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" /><a href="#Capabilities of the discovery service">服务发现的功能</a></li> </ul> <p>Signed-off-by: Maple-Chan<a href="mailto:f310815007@outlook.com">f310815007@outlook.com</a></p> </blockquote> <h2 id="service-discovery-集成测试中总结的功能">Service Discovery 集成测试中总结的功能</h2> <ol> <li> <p>服务发现orderer，org，证书+rootTLS证书 (对应Service Discovery CLI的config)</p> </li> <li> <p>查看有哪些链码。 （对应Service Discovery CLI的peers）</p> </li> <li> <p>服务发现找到背书节点，所有节点 (对应Service Discovery CLI的endorsers与peers)</p> <p>SDK中的Channel对象有 sendTransactionProposalToEndorsers方法，在该方法中传入DiscoveryOptions对象（在这个之中进行服务发现，进而向需要背书的节点发送交易）。</p> </li> </ol> <h2 id="service-discovery概念">Service Discovery概念</h2> <h3 id="why-do-we-need-service-discovery">Why do we need service discovery?</h3> <p><strong>为什么我们需要服务发现?</strong></p> <p>In order to execute chaincode on peers, submit transactions to orderers, and to be updated about the status of transactions, applications connect to an API exposed by an SDK.</p> <p>为了在 Peer 节点上执行链码，将交易提交给排序节点，并更新交易状态，应用程序需要连接 SDK 中开放的 API。</p> <p>However, the SDK needs a lot of information in order to allow applications to connect to the relevant network nodes. In addition to the CA and TLS certificates of the orderers and peers on the channel – as well as their IP addresses and port numbers – it must know the relevant endorsement policies as well as which peers have the chaincode installed (so the application knows which peers to send chaincode proposals to).</p> <p>然而，为了让应用程序连接到相关的网络节点，SDK 需要大量信息。除了通道上排序节点和 Peer 节点的 CA 证书和 TLS 证书及其 IP 地址和端口号之外，它还必须知道相关的背书策略以及安装了链码的 Peer 节点（这样应用程序才能知道将链码提案发送给哪个 Peer 节点）。</p> <p>Prior to v1.2, this information was statically encoded. However, this implementation is not dynamically reactive to network changes (such as the addition of peers who have installed the relevant chaincode, or peers that are temporarily offline). Static configurations also do not allow applications to react to changes of the endorsement policy itself (as might happen when a new organization joins a channel).</p> <p>在 v1.2 之前，这些信息是静态编码的。然而，这种实现不能动态响应网络的更改（例如添加已安装相关链码的 Peer 节点或 Peer 节点临时离线）。静态配置也不能让应用程序对背书策略本身的更改做出反应（比如通道中加入了新的组织）。</p> <p>In addition, the client application has no way of knowing which peers have updated ledgers and which do not. As a result, the application might submit proposals to peers whose ledger data is not in sync with the rest of the network, resulting in transaction being invalidated upon commit and wasting resources as a consequence.</p> <p>此外，客户端应用程序无法知道哪些 Peer 节点已更新账本，哪些未更新。因此该应用程序可能向网络中尚未同步账本的 Peer 节点提交提案，从而导致事务在提交时失效并浪费资源。</p> <p>The <strong>discovery service</strong> improves this process by having the peers compute the needed information dynamically and present it to the SDK in a consumable manner.</p> <p><strong>服务发现</strong> 通过让 Peer 节点动态计算所需信息，并以可消耗的方式将其提供给 SDK，从而改善了此过程。</p> <h3 id="how-service-discovery-works-in-fabric">How service discovery works in Fabric</h3> <p><strong>Fabric 中的服务发现是如何工作的</strong></p> <p>The application is bootstrapped knowing about a group of peers which are trusted by the application developer/administrator to provide authentic responses to discovery queries. A good candidate peer to be used by the client application is one that is in the same organization. Note that in order for peers to be known to the discovery service, they must have an <code class="language-plaintext highlighter-rouge">EXTERNAL_ENDPOINT</code> defined. To see how to do this, check out our <a href="https://hyperledger-fabric.readthedocs.io/en/latest/discovery-cli.html">Service Discovery CLI</a> documentation.</p> <p>应用程序启动时会通过设置得知应用程序开发人员或者管理员所信任的一组 Peer 节点，以便为发现查询提供可信的响应。客户端应用程序所使用的候选节点也在该（同一个）组织中。请注意，为了被服务发现所识别，Peer 节点必须定义一个 <a name="EXTERNAL_ENDPOINT"><code class="language-plaintext highlighter-rouge">EXTERNAL_ENDPOINT</code></a> 。想了解如何执行此操作，请查看我们的文档 <a href="https://hyperledger-fabric.readthedocs.io/zh_CN/latest/discovery-cli.html">服务发现命令行界面</a></p> <p>The application issues a configuration query to the discovery service and obtains all the static information it would have otherwise needed to communicate with the rest of the nodes of the network. This information can be refreshed at any point by sending a subsequent query to the discovery service of a peer.</p> <p>应用程序向发现服务发出<strong>配置查询</strong>并获取它所拥有的所有静态配置，否则（如果没有所有的静态信息）就需要与网络的其余节点通信。继续向 Peer 节点的发现服务发送查询，就可以随时刷新此信息。</p> <p>The service runs on peers – not on the application – and uses the network metadata information maintained by the gossip communication layer to find out which peers are online. It also fetches information, such as any relevant endorsement policies, from the peer’s state database.</p> <p>该服务在 <strong>Peer 节点</strong>（而不是应用程序）上运行，并使用 gossip 通信层维护的网络元数据信息来找出哪些 Peer 节点在线。它还从 Peer 节点的状态数据库中获取信息，例如相关的签名策略等。</p> <p>With service discovery, applications no longer need to specify which peers they need endorsements from. The SDK can simply send a query to the discovery service asking which peers are needed given a channel and a chaincode ID. The discovery service will then compute a descriptor comprised of two objects:</p> <p>通过服务发现，应用程序不再需要指定为他们背书的 Peer 节点。给定通道和链码 ID，SDK 就可以通过发现服务查询其所对应的 Peer 节点。然后，发现服务会计算出由两个对象组成的描述符：</p> <p><a name="group_jump">组的概念 </a></p> <ol> <li> <p><strong>Layouts</strong>: a list of groups of peers and a corresponding amount of peers from each group which should be selected.</p> <p><strong>布局</strong>：Peer 组的列表，以及每个组中应当选取的 Peer 节点数。</p> </li> <li> <p><strong>Group to peer mapping</strong>: from the groups in the layouts to the peers of the channel. In practice, each group would most likely be peers that represent individual organizations, but because the service API is generic and ignorant of organizations this is just a “group”.</p> <p><strong>组到 Peer 的映射</strong>:布局中的组和通道的 Peer 节点的对应。实际上，一个组很可能是代表一个组织的 Peer 节点，但是由于服务 API 是通用的并且与组织无关，因此这只是一个“组”。</p> </li> </ol> <p>The following is an example of a descriptor from the evaluation of a policy of <code class="language-plaintext highlighter-rouge">AND(Org1, Org2)</code> where there are two peers in each of the organizations.</p> <p>下面是一个<code class="language-plaintext highlighter-rouge">AND(Org1, Org2)</code>策略的描述符示例，其中每个组织中有两个 Peer 节点。</p> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">Layouts</span><span class="pi">:</span> <span class="pi">[</span>
     <span class="nv">QuantitiesByGroup</span><span class="pi">:</span> <span class="pi">{</span>   <span class="c1"># 节点中需要背书的节点的数量</span>
       <span class="nv">“Org1”</span><span class="pi">:</span> <span class="nv">1</span><span class="pi">,</span>
       <span class="nv">“Org2”</span><span class="pi">:</span> <span class="nv">1</span><span class="pi">,</span>
     <span class="pi">}</span>
<span class="pi">]</span><span class="err">,</span>
<span class="na">EndorsersByGroups</span><span class="pi">:</span> <span class="pi">{</span>
  <span class="nv">“Org1”</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">peer0.org1</span><span class="pi">,</span> <span class="nv">peer1.org1</span><span class="pi">],</span>
  <span class="nv">“Org2”</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">peer0.org2</span><span class="pi">,</span> <span class="nv">peer1.org2</span><span class="pi">]</span>
<span class="pi">}</span>
</code></pre></div></div> <p>In other words, the endorsement policy requires a signature from one peer in Org1 and one peer in Org2. And it provides the names of available peers in those orgs who can endorse (<code class="language-plaintext highlighter-rouge">peer0</code> and <code class="language-plaintext highlighter-rouge">peer1</code> in both Org1 and in Org2).</p> <p>换言之，背书策略需要两个分别来自 Org1 和 Org2 的 Peer 节点的签名。它提供了组织中可以背书的（Org1 和 Org2 中都有 <code class="language-plaintext highlighter-rouge">peer0</code> 和 <code class="language-plaintext highlighter-rouge">peer1</code>） Peer 节点的名称。</p> <p>The SDK then selects a random layout from the list. In the example above, the endorsement policy is Org1 <code class="language-plaintext highlighter-rouge">AND</code> Org2. If instead it was an <code class="language-plaintext highlighter-rouge">OR</code> policy, the SDK would randomly select either Org1 or Org2, since a signature from a peer from either Org would satisfy the policy.</p> <p>之后 SDK 会随机从列表中选择一个布局。在上边的例子中的背书策略是 Org1 <code class="language-plaintext highlighter-rouge">AND</code> Org2。如果换成 <code class="language-plaintext highlighter-rouge">OR</code> 策略，SDK 就会随机选择 Org1 或 Org2，因为任意一个节点的签名都可以满足背书策略。</p> <p>After the SDK has selected a layout, it selects from the peers in the layout based on a criteria specified on the client side (the SDK can do this because it has access to metadata like ledger height). For example, it can prefer peers with higher ledger heights over others – or to exclude peers that the application has discovered to be offline – according to the number of peers from each group in the layout. If no single peer is preferable based on the criteria, the SDK will randomly select from the peers that best meet the criteria.</p> <p>SDK 选择布局后，会根据客户端指定的标准对布局中的 Peer 节点进行选择（SDK 可以这样做是因为它能够访问元数据，比如账本高度）。例如，SDK 可以根据布局中每个组的 Peer 节点的数量，优先选择具有更高的账本高度的 Peer 节点，或者排除应用程序发现的处于脱机状态的 Peer 节点。如果无法根据标准选定一个 Peer 节点, SDK 将从最符合标准的 Peer 节点中随机选择。</p> <h4 id="capabilities-of-the-discovery-service">Capabilities of the discovery service</h4> <p><strong>服务发现的功能</strong></p> <p>The discovery service can respond to the following queries:</p> <p><strong>发现服务可以响应以下查询：</strong></p> <ul> <li> <p><strong>Configuration query</strong>: Returns the <code class="language-plaintext highlighter-rouge">MSPConfig</code> of all organizations in the channel along with the orderer endpoints of the channel.</p> <p><strong>配置查询</strong>： 从通道的排序节点返回通道中所有组织的 <code class="language-plaintext highlighter-rouge">MSPConfig</code>。</p> </li> <li> <p><strong>Peer membership query</strong>: Returns the peers that have joined the channel.</p> <p><strong>Peer 成员查询</strong>： 返回已加入通道的 Peer 节点。</p> </li> <li> <p><strong>Endorsement query</strong>: Returns an endorsement descriptor for given chaincode(s) in a channel.</p> <p><strong>背书查询</strong>： 返回通道中给定链码的背书描述符。</p> </li> <li> <p><strong>Local peer membership query</strong>: Returns the local membership information of the peer that responds to the query. By default the client needs to be an administrator for the peer to respond to this query.</p> <p><strong>本地 Peer 成员查询</strong>： 返回响应查询的 Peer 节点的本地成员信息。默认情况下，客户端需要是 <u>Peer 节点的管理员</u>才能响应此查询。</p> </li> </ul> <h4 id="special-requirements">Special requirements</h4> <p><strong>特殊要求</strong></p> <p>When the peer is running with TLS enabled the client must provide a TLS certificate when connecting to the peer. If the peer isn’t configured to verify client certificates (clientAuthRequired is false), this TLS certificate can be self-signed.</p> <p>当 Peer 节点在启用 TLS 的情况下运行时，客户端在连接到 Peer 节点时必须提供 TLS 证书。如果未将 Peer 节点配置为验证客户端证书（clientAuthRequired 为 false），则此 TLS 证书可以是自签名的。</p> <br> <nav class="pagination"> <a href="http://localhost:4000/Fabric-Operation-Service/" class="pagination_pager" title="Fabric: The Operation Service ">previous</a> <a href="http://localhost:4000/Fabric-Service-Discovery-CLI/" class="pagination_pager" title="Fabric: Service Discovery CLI ">next</a> </nav> </div> </div> <!-- JS --> <script src="http://localhost:4000/assets/js/main.min.js"></script> <div class="overlay"> <ul class="projects-menu"> <li style="background:url(http://localhost:4000/images/benjamin-deyoung-unsplash.jpg) center center no-repeat;"> <a href="https://github.com/Maple-Chan" target="_blank" rel="nofollow external"> <span> GitHub Home </span> </a> </li> <li style="background:url(http://localhost:4000/images/unsplash-image-4.jpg) center center no-repeat;"> <a href="https://blog.maplestory.work/page/app/randomCheckIn" target="_blank" rel="nofollow external"> <span> 点名小程序 </span> </a> </li> </ul> </div> </body> </html>
